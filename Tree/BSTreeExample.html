<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search Tree </title>
</head>

<script>


    class Node {
        constructor(nodeData) {
            this.value = nodeData;
            this.left = null;
            this.right = null;
        }
    }

    class BSTree {

        constructor(nodeData) {
            this.root = null;
        }

        insertNode = (root, newNode) => {

            if (root.value > newNode.value) {

                if (root.left === null) {
                    root.left = newNode
                }
                else {
                    this.insertNode(root.left, newNode);
                }

            }
            else {
                //righ side node builder logic
                if (root.right === null) {
                    root.right = newNode
                }
                else {
                    this.insertNode(root.right, newNode);
                }
            }
        }

        makeTree = (nodeData) => {
            let newNode = new Node(nodeData);
            if (this.root === null) {
                this.root = newNode
            }
            else {
                this.insertNode(this.root, newNode)
            }
        }

        // here i write a logic for explore node in bst

        // aama je return keyword important 6.

        search(root, find_element) {
            // debugger
            if (root === null) {
                return false
            }

            else if (root.value === find_element) {

                return true
            }
            else if (root.value > find_element) {
                return this.search(root.left, find_element)
            }

            else {
                return this.search(root.right, find_element)
            }
        }


        // here i write a DFS : Depth First Search Technique. it is a travelsing technique in tree.

        // DFS is in 3 way 
        /*
        
        1. Inorder : in this Travelsing start with root.
        2. Postorder: in this Travalsing start with lest leaf node.
        3. Preorder: in this Travalsing start with right side right leaf node.
        
        */

        inOrder(root) {
            if (root) {
                this.inOrder(root.left)
                console.log(root.value);
                this.inOrder(root.right)

            }
        }

        preOrder(root) {
            if (root) {
                console.log(root.value)
                this.preOrder(root.left)
                this.preOrder(root.right)
            }
        }
        postOrder(root) {
            if (root) {

                this.postOrder(root.left)
                this.postOrder(root.right)
                console.log(root.value)
            }
        }

        // here i write a BFS : Breath First Search Technique. it is a travelsing technique using a queue in tree.

        bfs() {
            let queue = []
            queue.push(this.root)
            while (queue.length) {
                let currant = queue.shift()
                if (currant.left) {
                    queue.push(currant.left)
                }
                if (currant.right) {
                    queue.push(currant.right)
                }

                console.log(currant.value)
            }
        }


        // delete node  in tree so in this 3 case possible:

        /*
        1. a leaf node delete 
        2. on node of which we can do delete
        3. node that can we delete that have 2 node
        
        */


        // minValue(root) {
        //     if (root) {
        //         this.minValue(root.left)
        //         if (root.left == null) {
        //             console.log(root.value)
        //         }
        //     }
        // }


        // another method for find minimum and maximum node in binary search tree.


        minValue(root) {

            if (!root.left) {
                console.log(root.value)
                return root.value
            }
            else {
                this.minValue(root.left)
            }
        }

        maxValue(root) {

            if (!root.right) {
                console.log(root.value)
                return root.value
            }
            else {
                this.maxValue(root.right)
            }
        }

        // maxValue(root) {
        //     if (root) {
        //         this.maxValue(root.right)
        //         if (root.right == null) {
        //             console.log(root.value)
        //         }
        //     }
        // }





        // removeNode(value) {
        //     this.root = this.deleteNode(this.root, value)

        // }



        // deleteNode(root, value) {

        //     if (root === null) {
        //         return null;
        //     }
        //     else if (root.value > value) {
        //         root.right = this.deleteNode(root.right, value)
        //     }
        //     else if (value > root.value) {
        //         root.left = this.deleteNode(root.left, value)
        //     }
        //     else {
        //         if (!root.right && !root.left) {
        //             return null
        //         }
        //         else if (!root.right) {
        //             return root.left
        //         }
        //         else if (!root.left) {
        //             return root.right
        //         }
        //         root.value = this.min


        //     }
    }



    let node = new BSTree()
    node.makeTree(20);
    node.makeTree(10)
    node.makeTree(5)
    node.makeTree(11)
    node.makeTree(30)
    node.makeTree(40)
    node.makeTree(23)
    // node.makeTree(10)
    // console.log(node.root)
    // let re = node.search(node.root, 10)
    // console.log(re)

    // node.inOrder(node.root)
    // node.bfs()
    node.minValue(node.root)
    node.maxValue(node.root)
</script>

<body>

</body>

</html>